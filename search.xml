<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue里的生命周期]]></title>
    <url>%2F2017%2F12%2F18%2Fvue%E9%87%8C%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[虽然网上能搜到一堆关于Vue2.0的生命周期的文章，但是基本都是将各个生命周期给介绍了一遍，这些文章对于初学者而言其实还是会一脸懵逼😐。这些详细的介绍对于已经使用Vue开发过实际项目的同学来讲，非常适合进阶，但是这里，我只想记分享下一些刚需的，基本每个项目都实用的东西。ok，开打开打！😎 聊之前咋们还是来简短介绍一遍每个周期函数，2333 ¶Vue里的各个生命周期 ¶1. beforeCreate 在这个阶段，你基本做不了什么操作…因为Vue实例都未创建🙃 ¶2. created 这里，基本上一个完整的Vue实例已经构建完成了，也就是说，你可以在这个阶段在组件里通过this拿到Vue实例，而且data和watach等Vue的选项也可以操作。但是Vue实例并未在真实DOM里渲染，所以你操作不了绑定的元素。我们可以在这个时期从后台获取数据，当然你也可以在后面的生命周期获取，但是建议在created就获取数据并且进行数据处理 ¶3. beforeMount 这个时候，只是Vue的render渲染函数开始运用，但是你仍然无法操作绑定的DOM ¶4. mounted 当生命周期进行到这个阶段，Vue实例的el选项已经可以使用，这个时候基本上所有Vue的选项都能正常使用，因为已经从虚拟DOM渲染到真实的DOM。 ¶5. beforeUpdate 这个钩子函数比较有意思，并不是DOM的更新才会触发该钩子函数，而是虚拟DOM。也是就说只要Vue已经created后，一旦data里的数据发生改变，在数据更改之前就可以触发此钩子函数。 ¶6. updated 和上面的生命周期函数类似，只是在数据发生改变，数据更改之后才会触发。 ¶7. beforeDestroy 当Vue实例被销毁前，那么什么时候才会被销毁呢？一般来说，我们很少会去手动注销实例，目前只知道通过Vue自带的$destroy方法才能销毁(我猜测直接将Vue赋值为null也行)。注意，这个时候，实例的所有属性仍然可以使用！ ¶8. destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 我只罗列了大部分的生命周期，因为以上的钩子函数会按照一定顺序运行一遍，而其它的像activated和errorCaptured等钩子函数，大家可以自行去官网了解。 ¶Vue的生命周期函数中需要注意的一些坑 ¶1. 什么时候从后台获取数据组好？ 其实Vue并没有规定什么时候获取数据最好，我们从每个钩子函数定义便可知，只要在Vue实例创建之后，也就是created中及以后的所有钩子函数里都可以从后台获取数据。但是，这里我建议大家还是在created钩子函数就获取数据，然后进行数据操作。原因嘛就是，从beforeCreate到mounted,这中间是一个流程，而且是不受任何东西影响的,并且数据请求是个异步的过程，而生命周期并不是等待数据返回再接着运行。举个例子： 123&lt;ul&gt; &lt;li v-for="item of source" :key="item" ref="item"&gt;&lt;/li&gt;&lt;/ul&gt; 1234567891011121314data()&#123; return&#123; source:[] &#125;&#125;,created()&#123; ...从后台获取数据 this.source = response//将data里数据赋值为获取到的数据&#125;,mounted()&#123; //假如有一个数组项值为'Alan' console.log(this.$refs.Alan) //这里可能会报错，此时的refs显示为未定义的Object的属性&#125; 为什么可能会报错呢？其实，在大多数网络情况下，是肯定会报错。因为数据请求是个异步的操作，取决于网络情况和数据量的大小，谁都不知道什么时候才会返回完整的数据。而Vue的周期函数不会等待数据全部返回完毕后再接着从created往下走，而是一旦created了，就会接着beforeMount,然后mounted。所以，当我们在mounted里试图通过$refs属性获取v-for渲染的DOM时就会报错了，因为在mounted阶段，说不准数据还没返回完呢🙄 那虚拟DOM就还没完全渲染出真实DOM😜。当然，只有通过v-for渲染的DOM才会受影响。其余的我们自己写的正常html标签都可以正常获取… 那么，应该怎样获取我们通过后台返回数据而渲染的DOM节点呢？ ¶2. updated是个好东西😝 通过上文即可知道，updated是不需要渲染真实DOM之后才能调用的钩子。也就是说，我们不需要担心什么时候真实DOM才会被渲染完成。上述代码改成这样： 123&lt;ul&gt; &lt;li v-for="item of source" :key="item" ref="item"&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516data()&#123; return&#123; source:[] &#125;&#125;,created()&#123; ...从后台获取数据 this.source = response//将data里数据赋值为获取到的数据&#125;,updated()&#123; this.$nextTick(()=&gt;&#123; //假如有一个数组项值为'Alan' console.log(this.$refs.Alan) //这里可能会报错，此时的refs显示为未定义的Object的属性 &#125;)&#125; 只要原始数据source发生了改变，就可以在updated里执行代码。这里要注意的是，我使用了一个Vue的自带方法$nextTick。这个方法的意思是把回调函数内的操作延迟到下一个DOM更新循环之后。这又是个啥玩意？😂。嘛，其实Vue本身会将所有DOM更新的操作放入一个队列里，然后根据实际情况(应该会考虑到性能)一个接一个执行真实的DOM更新(局部更新)，$nextTick就是会将方法内回调函数的操作延迟到队列里下一个DOM更新后执行。也就是说，会等到source获取完毕，然后真实DOM渲染完成后才执行。$nextTick非常常用，只要涉及到数据更新，就应该执行这个方法。 ¶总结 Vue的生命周期函数为开发者提供了非常便利的操作。但是善用生命周期才会不踩坑，一定需要注意数据获取是个异步过程，而生命周期函数的运行是独立的！只要涉及到DOM更新的操作，一定要使用$nextTick！😉 哦啦，下次我想写写vue-router的生命周期函数，非常的强大哦~]]></content>
      <categories>
        <category>前端编程</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM里的attribute和property]]></title>
    <url>%2F2017%2F12%2F06%2FDOM%E9%87%8C%E7%9A%84attribute%E5%92%8Cproperty%2F</url>
    <content type="text"><![CDATA[在偶然间使用vue里的v-bind指令，发现v-bind竟然还有一个prop的修饰符。喵喵喵？😎一下子我的好奇心就来，vue的中文文档翻译为被用于绑定 DOM 属性 (property)。什么叫做DOM属性？然后这篇文章就来了… 还是先讲讲使用这个修饰符我遇到的坑吧，首先，我试了试在v-bind上绑定visibility特性(请注意我目前的措辞),大概代码如下： 1&lt;div :visibility.prop="false"&gt;看的到我嘛？&lt;/div&gt; 但是结果并不是div标签被隐藏掉，而是什么事情都不发生。What’s the fuck?😳不死心的我又尝试去掉了prop修饰符，结果虽然有了效果，但是也不是div被隐藏，而是div标签上多了一个自定义属性，在浏览器里像这样： 1&lt;div visibility="false"&gt;看的到我嘛？&lt;/div&gt; 坑爹啊…vue api文档里不是说可以改变DOM自带的属性嘛？其实vue里v-bind有点坑，但是之所以不生效，是因为我之前没有理解DOM里attribute和property的问题。😭 ok，现在进入show time时间&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 什么叫做DOM的属性 属性这个名称其实是对英文翻译的误解，因为在DOM里是有两个单词来解释的，一个是attribute,一个是property，这两个单词其实都有属性的意思，但是又各有不同。所以在我查了很多博客和segmentfault社区之后发现，目前最好的翻译应该是attribute—&gt;特性，property—&gt;属性。 那attribute和property到底又分别是代表什么呢？ ¶1. attribute是开发者自行添加的特性，property是标签自带的属性 什么意思呢？也就是说，attribute是开发者自行在html标签里添加的，不是DOM节点自带的，而property是只要你创建了这个html标签，就存在，举个例子： 1&lt;div id="box" value="2333" data-sex="male"&gt;我是一个div&lt;/div&gt; 我们通过javascript获取DOM的方式获取DOM节点(有NodeList和HTMLCollection两种)，最好通过document.getElementsByTagName或document.getElementsByClassName来获取，因为打印的是一个集合，否则用其余方法获取的打印出来是一个标签节点 id和data-sex都是div这个节点自带的，我们可以在这个节点对象属性里看到，这些就叫做这个节点对象的property。而value是我们自行添加，并不是标签原本就有，属于自定义特性，我们可以在这个节点对象的attributes属性里看到。 但是有一个很有意思的地方，就是虽然id和data-sex是节点对象的property，然而我们依然可以在attributes找到，说明attributes里存放的是我们在html标签写的所有(包括自带和自定义)。 ¶2. attribute和property其实定义没有明确的界限 vue里关于v-bind绑定DOM属性解释的链接是stackoverflow上的答案，这也是我查到的最全面也是最正确的解释。 property是每个html被创建时就存在的属性，就算我们不在标签里写上id，DOM节点对象里也存在id属性，而且property对于不同的html标签所对应的属性也不相同。比如：input有value和type属性，div就没有。a有href属性，div就没有。img有src属性(这里有v-bind设计的坑)，div就没有，button有disabled，别的就没有。但是都会有共有的一些属性，比如：accessKey，textContent，title,hidden… attribute是开发者自行添加在html标签上的，可以是节点对象原本就有的，也可以是自定义的特性。只要在html标签上写了，我们就可以在节点对象的attributes属性里找到。 ¶3. attribute和property读写存在区别 对于property，我们可以直接通过对象的属性这种方式来读写，比如： 12345const box = document.querySelector('#box')console.log(box.id) // 打印出出 boxconsole.log(box.dataset.sex) // 打印出 malebox.id = 'alan'console.log(box.id) // 打印出出 alan 对于attribute，我们只能通过DOM给定的方法getAttribute()和setAttribute()来读写，当然，也可以通过DOM节点对象的attributes属性获取，两者是等价的,获取class时，DOM节点的className和通过getAttribute('class')也是等价的。请注意：这两种方法也适用于读写property，但是它们存在细微的差别。 getAttribute()获取到的值永远是string类型，我们可以试一下： 1consloe.log(typeof box.getAttribute('draggable')) // 打印出string，但是我们从上图可以看出'draggable'明明是boolean类型 setAttribute()在设置attribute特性时，参数必须是字符串，但是在设置property时可以是任何类型，这里发现了一个有趣的现象，当我在设置draggable时，除了false(Boolean)和’false’(String)可以让draggable为false外，其余设置的值都为true。所以我大胆猜测，DOM节点对于property有着严格的限制，对值的类型应该做了转换。 ¶4. attribute和property写入有时同步，有时不同步 回到上面改变id的例子上，我们通过写入property改变了id属性，发现，页面里的html也发生了的变化，并且在此之后获取的attribute也同步发生了改变 1&lt;div id="alan" value="2333" data-sex="male"&gt;&lt;/div&gt; 1234const box = document.querySelector('#box')box.id = 'alan'console.log(box.id) // 打印出出 alanconsole.log(box.getAttribute('id')) // 打印出出 alan 我在stackoverflow上发现，除了input里的value属性不会导致属性和特性同步外，其余的都会同步。当然大家最好还是自己测一测😉 在使用javascript的过程中，强烈建议大家通过setAttribute()来设置属性和特性，但是对于读取，还是得分开获取，因为getAttribute()只会获取到string，或者说，会强制把值改为string vue的v-bind里对DOM的属性和特性有什么区别 现在回到文章开头的那个问题，prop这个修饰符意义到底在哪里。结合前面讲的所有知识，大概就能知道prop只适用于改变property。因为在vue的v-bind指令里，默认是给组件或者html标签添加attribute。很明显visibility不是property，而是attribute，如果想要使用prop来让标签隐藏，我们可以改为 1&lt;div :hidden.prop="false"&gt;看的到我嘛？&lt;/div&gt; 这样div就会被隐藏了，因为hidden是DOM节点对象的属性 不得不讲的v-bind的api设计坑的地方: v-bind在英文文档里明明写着是绑定一个DOM特性或者组件的props，但是我在使用的时候，发现img标签可以直接:src，What’s the fuck?😳，你特喵的不是专门出了个prop修饰符来专门绑定DOM property嘛，那为什么src就直接绑定了，还有title，id等等都可以在不使用prop修饰符的情况下直接绑定成功…这就为难我胖虎了🙄 我只好理解为：vue允许v-bind可以直接绑定常用的DOM property，对于不常用的，或者说一般不会写在html的property只能用prop修饰符来搞定了…23333神坑 写在最后，我用textContent属性直接就实现了v-text的功能，innerHTML直接就实现了v-html的功能😝。最后的最后，我好像发现了vue通过props让父组件传值给子组件的原理。害怕.jpg😁,至于思路，我就不讲啦，哈哈哈，其实就是这篇文章里讲到的。]]></content>
      <categories>
        <category>前端编程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>HTML</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊博客搬家]]></title>
    <url>%2F2017%2F12%2F03%2F%E8%81%8A%E4%B8%80%E8%81%8A%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[来来回回折腾了好久，最后还是准备重新开始收拾自己的博客啦…最开始本来是想在wordpress一直待下去，奈何没钱买服务器，23333. 请理解一个穷逼码农的日常没钱！ 好了，新的博客已经完全转到了hexo加GitHub page的怀抱，谁叫GitHub财大气粗免费呢。果然不愧是全球最大的同性交友网站 😄 之前在wordpress那个博客上写过几篇关于es3的知识，自己打算以后不再写es3的内容了。一是es3目前虽然还在使用，但是es6发展如此迅速，es3不断被开发者放弃是迟早的事。二是我自己对于es语法的理解可能也仅限于一点点皮毛，如果再写，要是误导人就完蛋啦…😵 这个博客以后就用来给自己写写吐槽，然后记一记敲代码过程中学习到的一些知识。以后可能就会经常写框架的知识点啦，哈哈哈😎毕竟现在mvvm框架和webpack以及node是前端主流了，要是再不积极学习这些框架，可能就要gg… 😓 请不要吐槽我的排版，只用markdown写过github README的我已经很用心的在写了，你看，这不还加了emoji😝]]></content>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
</search>
